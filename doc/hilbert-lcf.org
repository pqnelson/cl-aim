#+TITLE: LCF for Hilbert Calculus
#+AUTHOR: Alex Nelson
#+EMAIL: pqnelson@gmail.com
#+LANGUAGE: en
#+OPTIONS: H:5
#+HTML_DOCTYPE: html5
# Created Monday December  7, 2020 at  5:13PM

* Overview

The LCF style prover for logic is built atop a Hilbert proof
calculus. The basic idea is to have as few inference rules as
possible, and a large library of axioms. Our only connectives are
=implies= and =contradiction= for propositional logic, and
universal quantification added for first-order logic.

* Encoding the Axioms of the Hilbert Calculus

We have a number of axioms, which we encode using =defaxiom=. This
creates a function in [[../src/fol/axiom.lisp][=cl-aim.fol.axiom=]] which accepts some
metavariables, then produces a =thm= object.

The =thm= abstraction is used to contain proven =formula=
statements. We adopt the vdash/turnstile notation to indicate a
formula is proven (=|- fm= means that the formula ~fm~ has been proven).
Axioms are the starting point for proving results: they are =thm= factories.

We encode inference rules as taking =thm= objects and producing a
new =thm= object.

The various axioms are defined in [[../src/fol/hilbert.lisp][hilbert.lisp]] and that's all I'm
concerned about at the moment.

* LCF Rules

Nothing comes for free with LCF, and we need to use the axioms
given to derive useful inference rules. This is done precisely in
[[../src/fol/lcf.lisp][=lcf.lisp=]], which is probably as exciting as Homer's catalog of
ships. Each inference rule is tested.

So far, a good chunk of propositional logic has been encoded.

What's left is to write a simple prover engine. 
